<!doctype html>
<html lang="en">
<head>
  <title>Template (Three.js)</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="node_modules/three/three.js"></script>
<script src="src/util/three/stats.min.js"></script>
<script src="src/util/three/OrbitControls.js"></script>

<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>

  'use strict';
  /*
   Three.js "tutorials by example"
   Author: Lee Stemkoski
   Date: July 2013 (three.js v59dev)
   */

  // MAIN

  // standard global variables
  var container, scene, camera, renderer, controls, stats;
  var clock = new THREE.Clock();

  // custom global variables
  var checkerMesh;
  var hasMoved = false;
  var isMoving = false;

  var tempStartVector = new THREE.Vector3( 0, 0, 0 );
  var tempEndVector = new THREE.Vector3( 1, 1, 1 );
  var startTime = 0;
  var translateSpeed = 1;
  var journeyDist = 0;

  init();
  animate();

  // FUNCTIONS
  function init()
  {
    // SCENE
    scene = new THREE.Scene();
    // CAMERA
    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
    var VIEW_ANGLE = 60, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene.add(camera);
    camera.position.set( 0, 150, 400 );
    camera.lookAt(scene.position);
    // RENDERER
    renderer = new THREE.WebGLRenderer( {antialias:true} );
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFSoftShadowMap;
    renderer.physicallyBasedShading = true;

    container = document.getElementById( 'ThreeJS' );
    container.appendChild( renderer.domElement );

    // EVENTS

    // CONTROLS
    controls = new THREE.OrbitControls( camera, renderer.domElement );
    // STATS
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.bottom = '0px';
    stats.domElement.style.zIndex = 100;
    container.appendChild( stats.domElement );

    // LIGHTS
    var light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0,150,100);
    light.castShadow = true;
    light.shadowCameraVisible = true;
    scene.add(light);

    var light2 = new THREE.AmbientLight(0x444444);


    // FLOOR
 /*   var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);*/

    // SKYBOX
    var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
    var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
    var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
    scene.add(skyBox);

    ////////////
    // CUSTOM //
    ////////////

    var squareTextureArrSize = 6;

    var lightTextures = [];
    var darkTextures = [];

    var lightMaterials = [];
    var darkMaterials = [];

    var arrowTextures = [];
    var arrowMaterials = [];
    var arrowImageNames = [
      "images/arrow-up.png",
      "images/arrow-right.png",
      "images/arrow-down.png",
      "images/arrow-left.png"
    ];

    var loader = new THREE.ImageLoader();

    // Init the arrays
    for( var i = 0; i < squareTextureArrSize; ++i ) {
      lightTextures.push( new THREE.Texture() );
      darkTextures.push( new THREE.Texture() );

      lightMaterials.push( new THREE.MeshLambertMaterial( { color: 0xffffff, map: lightTextures[i] } ) );
      darkMaterials.push( new THREE.MeshLambertMaterial( { color: 0xffE0E0, map: darkTextures[i] } ) );
    }

    for( var i = 0; i < arrowImageNames.length; ++i ) {
      // Since loading the images is an async call, we need
      // to init the array to have the necessary elements now,
      // and then update the material once the texture loads.
      arrowMaterials.push( new THREE.MeshBasicMaterial( { color: 0xffffff, map: new THREE.Texture(), transparent: true } ) );
      loader.load( arrowImageNames[i],
        ( function( index ) {
            return function( image ) {
              arrowMaterials[index].map.image = image;
              arrowMaterials[index].map.wrapS = arrowMaterials[index].map.wrapT = THREE.RepeatWrapping;
              arrowMaterials[index].map.needsUpdate = true;
            }
          } )( i ) );
    }

    var mainTexture = THREE.ImageUtils.loadTexture( 'images/board.jpg', null, function( texture ) {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 2, 2 );

      var initTexture = function( texture, image, index, flipY ) {
        texture.image = image;
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set( 0.25, 0.25 );
        texture.offset.set( index * 0.1, index * 0.1 );
        texture.flipY = flipY;
        texture.needsUpdate = true;
      };

      for( var i = 0; i < squareTextureArrSize; ++i ) {
        initTexture( lightTextures[i], texture.image, i, true );
        initTexture( darkTextures[i], texture.image, i, true );
      }
    } );

    var fixUVs = function( geometry ) {
      for( var t = 0; t < geometry.faceVertexUvs.length; ++t ) {
        for( var u = 0; u < geometry.faceVertexUvs[t].length; ++u ) {
          for( var v = 0; v < geometry.faceVertexUvs[t][u].length; ++v ) {
            var uv = geometry.faceVertexUvs[t][u][v];
            if( uv.x > 0 ) { uv.x = 1 }
            if( uv.y > 0 ) { uv.y = 1 }
          }
        }
      }
      geometry.uvsNeedUpdate = true;
    };

    var flipFaces = function( geometry ) {
      for ( var i = 0; i < geometry.faces.length; i ++ ) {
        var face = geometry.faces[ i ];
        var temp = face.a;
        face.a = face.c;
        face.c = temp;
      }

      geometry.computeFaceNormals();
      geometry.computeVertexNormals();

      var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
      for ( var i = 0; i < faceVertexUvs.length; i ++ ) {
        var temp = faceVertexUvs[ i ][ 0 ];
        faceVertexUvs[ i ][ 0 ] = faceVertexUvs[ i ][ 2 ];
        faceVertexUvs[ i ][ 2 ] = temp;
      }

      geometry.uvsNeedUpdate = true;
    };

    var centerGeometryOnAxis = function( geometry ) {
      geometry.computeBoundingBox();
      var translation = new THREE.Vector3()
          .subVectors( geometry.boundingBox.max, geometry.boundingBox.min )
          .multiplyScalar( 0.5 )
          .negate();
      geometry.applyMatrix( new THREE.Matrix4().makeTranslation( translation.x, translation.y, translation.z ) );
    };

    var rotateGeometry = function( geometry, axis, radians ) {
      var matrix = new THREE.Matrix4();
      switch ( axis ) {
        case 'x' :
          geometry.applyMatrix( new THREE.Matrix4().makeRotationX( radians ) );
          break;
        case 'y' :
          geometry.applyMatrix( new THREE.Matrix4().makeRotationY( radians ) );
          break;
        case 'y' :
          geometry.applyMatrix( new THREE.Matrix4().makeRotationZ( radians ) );
          break;
      }
    };

    var squareSize = 80;
    var boardSize = 3;

    // Create the board.

    // Lathe
    var boardLength = ( squareSize + 2 ) * boardSize;
    var boardPoints = [];
    boardPoints.push( new THREE.Vector3( 0,               0, 0 ) );
    boardPoints.push( new THREE.Vector3( 0,               0, 6 ) );
    boardPoints.push( new THREE.Vector3( boardLength - 5, 0, 6 ) );
    boardPoints.push( new THREE.Vector3( boardLength,     0, 1 ) );
    boardPoints.push( new THREE.Vector3( boardLength,     0, 0 ) );
    boardPoints.push( new THREE.Vector3( 0,               0, 0 ) );

    var mainMaterial = new THREE.MeshLambertMaterial( { color: 0x808080, map: mainTexture } );

    var boardGeo = new THREE.LatheGeometry( boardPoints, 4 );
    flipFaces( boardGeo );

    var boardMesh = new THREE.Mesh( boardGeo, mainMaterial );
    boardMesh.castShadow = true;
    boardMesh.receiveShadow = true;

    //boardMesh.add( new THREE.AxisHelper( 20 ) );

    rotateGeometry( boardMesh.geometry, 'x', -Math.PI/2 );
    rotateGeometry( boardMesh.geometry, 'y', -Math.PI/4 );

    scene.add( boardMesh );

    // SQUARES

    var squareMaterials = [];
    for( var i = 0; i < squareTextureArrSize; ++i ) {
      squareMaterials.push( lightMaterials[i] );
      squareMaterials.push( darkMaterials[i] );
    }
    for( var i = 0; i < arrowMaterials.length; ++i ) {
      squareMaterials.push( arrowMaterials[i] );
    }

    // Basic Square

    var createQuad = function( width, height ) {
      var quad = new THREE.Shape();

      quad.moveTo( 0,     0 );
      quad.lineTo( 0,     height );
      quad.lineTo( width, height );
      quad.lineTo( width, 0 );
      quad.lineTo( 0,     0 );

      var geo = new THREE.ShapeGeometry( quad );
      // by default, the shapes use the extrude geometry UVGenerator.
      // We are going to iterate over the UV array and set values
      // greater than 1 to 1.
      fixUVs( geo );

      return geo;
    };

    var squareMesh = new THREE.Mesh( createQuad( squareSize, squareSize ) );

    var createSquareArray = function( cloneMesh, boardSize, squareSize ) {
      var arr = [];
      var yPos = 0,
          xPos = 0;
      for( var y = 0; y < boardSize; ++y ) {
        xPos = 0;
        for( var x = 0; x < boardSize; ++x ) {
          var mesh = cloneMesh.clone();
          //mesh.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( xPos, 0, yPos ) );
          mesh.position.set( xPos, yPos, 0 );
          arr.push( mesh );
          xPos += squareSize;
        }
        yPos += squareSize;
      }
      return arr;
    };

    var squareMeshes = createSquareArray( squareMesh, boardSize, squareSize );

    var arrowSize = squareSize / 4;
    var arrowMesh = new THREE.Mesh( createQuad( arrowSize, arrowSize ) );
    // Move the arrow mesh to be in the lower left corner.
    arrowMesh.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( squareSize - arrowSize - 5, 5, 0.1 ) );

    // TEST BUSINESS
    //arrowMesh.add( new THREE.AxisHelper( 20 ) );
    //arrowMesh.material = arrowMaterials[0];
    //arrowMesh.position.set( -squareSize / 2 , 6.8 , squareSize / 2 );
    //scene.add(arrowMesh);

    var arrowMeshes = createSquareArray( arrowMesh, boardSize, squareSize );

    // Combine our meshes.
    var combinedGeometry = new THREE.Geometry();

    var maxSquareMat = squareTextureArrSize * 2;
    var materialIndex = 0;
    var isEven = boardSize % 2 === 0;

    // Add the squares first.
    for( var i = 0; i < squareMeshes.length; ++i ) {
      // Figure out the material index.
      var isNewRow = ( i % boardSize ) === 0;
      //var isOddRow = ( i / boardSize % 2 ) === 1;
      if( isEven && isNewRow ) {
        materialIndex += 2;
      } else {
        materialIndex++;
      }
      if( materialIndex >= maxSquareMat ) {
        materialIndex -= maxSquareMat;
      }
      squareMeshes[i].updateMatrix();
      combinedGeometry.merge( squareMeshes[i].geometry, squareMeshes[i].matrix, materialIndex );
    }

    // Now add the arrows.
    for( var i = 0; i < arrowMeshes.length; ++i ) {
      arrowMeshes[i].updateMatrix();
      // random material index.
      var matIndex = Math.floor( Math.random() * 4 ) + squareTextureArrSize * 2;
      combinedGeometry.merge( arrowMeshes[i].geometry, squareMeshes[i].matrix, matIndex );
    }

    combinedGeometry.mergeVertices();

    var meshCombined = new THREE.Mesh( combinedGeometry, new THREE.MeshFaceMaterial( squareMaterials ) );
    //meshCombined.add( new THREE.AxisHelper( 20 ) );
    meshCombined.receiveShadow = true;

    centerGeometryOnAxis( meshCombined.geometry );
    rotateGeometry( meshCombined.geometry, 'x', -Math.PI / 2 );

    meshCombined.position.set( 0, 6.4, 0 );

    scene.add( meshCombined );

    // Create the checker.
    var checkerSize = squareSize / 2 * 0.75;
    var ridgeSize = checkerSize * 0.2;
    var checkerPoints = [];
    checkerPoints.push( new THREE.Vector3( 0,                 0, 2 ) );
    checkerPoints.push( new THREE.Vector3( checkerSize - ridgeSize, 0, 2 ) );
    checkerPoints.push( new THREE.Vector3( checkerSize - ridgeSize, 0, 2 + ridgeSize ) );
    checkerPoints.push( new THREE.Vector3( checkerSize,       0, 2 + ridgeSize ) );
    checkerPoints.push( new THREE.Vector3( checkerSize,       0, 0 ) );
    checkerPoints.push( new THREE.Vector3( 0,                 0, 0 ) );

    var checkerMaterial = new THREE.MeshLambertMaterial( { color: 0xFF4040, map: mainTexture } );

    var checkerGeo = new THREE.LatheGeometry( checkerPoints, 24 );
    flipFaces( checkerGeo );

    checkerMesh = new THREE.Mesh( checkerGeo, checkerMaterial );
    checkerMesh.castShadow = checkerMesh.receiveShadow = true;

    rotateGeometry( checkerMesh.geometry, 'x', -Math.PI /2 );
    checkerMesh.position.set( squareSize, 10.5, 6.5 );

    //checkerMesh.add( new THREE.AxisHelper( 20 ) );

    scene.add( checkerMesh );

    tempStartVector = checkerMesh.position.clone();
    tempEndVector = new THREE.Vector3( squareSize, 10.5, squareSize );
  }

  function animate()
  {
    requestAnimationFrame( animate );
    render();
    update();
  }

  function update()
  {

    if( !hasMoved && !isMoving ) {
      isMoving = true;
      startTime = clock.getElapsedTime();
      journeyDist = tempStartVector.distanceToSquared( tempEndVector );
    }

    if( isMoving ) {
      var step = ( clock.getElapsedTime() - startTime ) / translateSpeed;
      if( step >= 1 ) {
        isMoving = false;
        hasMoved = true;
      } else {
        var newPos = lerpVector3( tempStartVector, tempEndVector, step );
        checkerMesh.position.set( newPos.x, newPos.y, newPos.z );
      }
    }
    stats.update();
  }

  function render()
  {
    renderer.render( scene, camera );
  }

  function lerpVector3( start, end, step ) {
    return new THREE.Vector3 (
      start.x + step * ( end.x - start.x ),
      start.y + step * ( end.y - start.y ),
      start.z + step * ( end.z - start.z )
    );
  }

  function makeTextSprite( message, parameters )
  {
    if ( parameters === undefined ) parameters = {};

    var fontface = parameters.hasOwnProperty("fontface") ?
        parameters["fontface"] : "Arial";

    var fontsize = parameters.hasOwnProperty("fontsize") ?
        parameters["fontsize"] : 18;

    var borderThickness = parameters.hasOwnProperty("borderThickness") ?
        parameters["borderThickness"] : 4;

    var borderColor = parameters.hasOwnProperty("borderColor") ?
        parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };

    var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
        parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

    //var spriteAlignment = THREE.SpriteAlignment.topLeft;

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.font = "Bold " + fontsize + "px " + fontface;

    // get size data (height depends only on font size)
    var metrics = context.measureText( message );
    var textWidth = metrics.width;

    // background color
    context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
    + backgroundColor.b + "," + backgroundColor.a + ")";
    // border color
    context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
    + borderColor.b + "," + borderColor.a + ")";

    context.lineWidth = borderThickness;
    roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
    // 1.4 is extra height factor for text below baseline: g,j,p,q.

    // text color
    context.fillStyle = "rgba(0, 0, 0, 1.0)";

    context.fillText( message, borderThickness, fontsize + borderThickness);

    // canvas contents will be used for a texture
    var texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;

    var spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
    var sprite = new THREE.Sprite( spriteMaterial );
    sprite.scale.set( 100, 50, 1.0 );
    return sprite;
  }

  // function for drawing rounded rectangles
  function roundRect(ctx, x, y, w, h, r)
  {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

</script>

</body>
</html>
